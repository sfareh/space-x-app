/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createBuilder, targetFromTargetString, } from '@angular-devkit/architect';
import { normalizeOptimization } from '@angular-devkit/build-angular/src/utils/normalize-optimization';
import { augmentAppWithServiceWorker } from '@angular-devkit/build-angular/src/utils/service-worker';
import { normalize, resolve as resolvePath } from '@angular-devkit/core';
import * as fs from 'fs';
import ora from 'ora';
import * as path from 'path';
import Piscina from 'piscina';
import { promisify } from 'util';
import { getIndexOutputFile, getRoutes } from './utils';
export const readFile = promisify(fs.readFile);
/**
 * Schedules the server and browser builds and returns their results if both builds are successful.
 */
function _scheduleBuilds(options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const browserTarget = targetFromTargetString(options.browserTarget);
        const serverTarget = targetFromTargetString(options.serverTarget);
        const browserTargetRun = yield context.scheduleTarget(browserTarget, {
            watch: false,
            serviceWorker: false,
            // todo: handle service worker augmentation
        });
        const serverTargetRun = yield context.scheduleTarget(serverTarget, {
            watch: false,
        });
        try {
            const [browserResult, serverResult] = yield Promise.all([
                browserTargetRun.result,
                serverTargetRun.result,
            ]);
            const success = browserResult.success && serverResult.success && browserResult.baseOutputPath !== undefined;
            const error = browserResult.error || serverResult.error;
            return { success, error, browserResult, serverResult };
        }
        catch (e) {
            return { success: false, error: e.message };
        }
        finally {
            yield Promise.all([browserTargetRun.stop(), serverTargetRun.stop()]);
        }
    });
}
/**
 * Renders each route and writes them to
 * <route>/index.html for each output path in the browser result.
 */
function _renderUniversal(routes, context, browserResult, serverResult, browserOptions, numProcesses) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const projectName = context.target && context.target.project;
        if (!projectName) {
            throw new Error('The builder requires a target.');
        }
        const root = normalize(context.workspaceRoot);
        const projectMetadata = yield context.getProjectMetadata(projectName);
        const projectRoot = resolvePath(root, normalize(projectMetadata.root || ''));
        // Users can specify a different base html file e.g. "src/home.html"
        const indexFile = getIndexOutputFile(browserOptions);
        const { styles: normalizedStylesOptimization } = normalizeOptimization(browserOptions.optimization);
        const { baseOutputPath = '' } = serverResult;
        const worker = new Piscina({
            filename: path.join(__dirname, 'worker.js'),
            name: 'render',
            maxThreads: numProcesses,
        });
        try {
            // We need to render the routes for each locale from the browser output.
            for (const outputPath of browserResult.outputPaths) {
                const localeDirectory = path.relative(browserResult.baseOutputPath, outputPath);
                const serverBundlePath = path.join(baseOutputPath, localeDirectory, 'main.js');
                if (!fs.existsSync(serverBundlePath)) {
                    throw new Error(`Could not find the main bundle: ${serverBundlePath}`);
                }
                const spinner = ora(`Prerendering ${routes.length} route(s) to ${outputPath}...`).start();
                try {
                    const results = (yield Promise.all(routes.map((route) => {
                        const options = {
                            indexFile,
                            deployUrl: browserOptions.deployUrl || '',
                            inlineCriticalCss: !!normalizedStylesOptimization.inlineCritical,
                            minifyCss: !!normalizedStylesOptimization.minify,
                            outputPath,
                            route,
                            serverBundlePath,
                        };
                        return worker.run(options, { name: 'render' });
                    })));
                    let numErrors = 0;
                    for (const { errors, warnings } of results) {
                        spinner.stop();
                        errors === null || errors === void 0 ? void 0 : errors.forEach((e) => context.logger.error(e));
                        warnings === null || warnings === void 0 ? void 0 : warnings.forEach((e) => context.logger.warn(e));
                        spinner.start();
                        numErrors += (_a = errors === null || errors === void 0 ? void 0 : errors.length) !== null && _a !== void 0 ? _a : 0;
                    }
                    if (numErrors > 0) {
                        throw Error(`Rendering failed with ${numErrors} worker errors.`);
                    }
                }
                catch (error) {
                    spinner.fail(`Prerendering routes to ${outputPath} failed.`);
                    return { success: false, error: error.message };
                }
                spinner.succeed(`Prerendering routes to ${outputPath} complete.`);
                if (browserOptions.serviceWorker) {
                    spinner.start('Generating service worker...');
                    try {
                        yield augmentAppWithServiceWorker(projectRoot, normalize(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath);
                    }
                    catch (error) {
                        spinner.fail('Service worker generation failed.');
                        return { success: false, error: error.message };
                    }
                    spinner.succeed('Service worker generation complete.');
                }
            }
        }
        finally {
            void worker.destroy();
        }
        return browserResult;
    });
}
/**
 * Builds the browser and server, then renders each route in options.routes
 * and writes them to prerender/<route>/index.html for each output path in
 * the browser result.
 */
export function execute(options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const browserTarget = targetFromTargetString(options.browserTarget);
        const browserOptions = (yield context.getTargetOptions(browserTarget));
        const tsConfigPath = typeof browserOptions.tsConfig === 'string' ? browserOptions.tsConfig : undefined;
        const routes = yield getRoutes(options, tsConfigPath, context);
        if (!routes.length) {
            throw new Error(`Could not find any routes to prerender.`);
        }
        const result = yield _scheduleBuilds(options, context);
        const { success, error, browserResult, serverResult } = result;
        if (!success || !browserResult || !serverResult) {
            return { success, error };
        }
        return _renderUniversal(routes, context, browserResult, serverResult, browserOptions, options.numProcesses);
    });
}
export default createBuilder(execute);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9wcmVyZW5kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7O0FBRUgsT0FBTyxFQUdMLGFBQWEsRUFDYixzQkFBc0IsR0FDdkIsTUFBTSwyQkFBMkIsQ0FBQztBQUVuQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxnRUFBZ0UsQ0FBQztBQUN2RyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSx3REFBd0QsQ0FBQztBQUNyRyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sSUFBSSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RSxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDdEIsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxPQUFPLE1BQU0sU0FBUyxDQUFDO0FBQzlCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFakMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUd4RCxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQWEvQzs7R0FFRztBQUNILFNBQWUsZUFBZSxDQUM1QixPQUFnQyxFQUNoQyxPQUF1Qjs7UUFFdkIsTUFBTSxhQUFhLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sWUFBWSxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUVsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUU7WUFD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LENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQnVpbGRlckNvbnRleHQsXG4gIEJ1aWxkZXJPdXRwdXQsXG4gIGNyZWF0ZUJ1aWxkZXIsXG4gIHRhcmdldEZyb21UYXJnZXRTdHJpbmcsXG59IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9hcmNoaXRlY3QnO1xuaW1wb3J0IHsgQnJvd3NlckJ1aWxkZXJPcHRpb25zIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXInO1xuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW1pemF0aW9uIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXIvc3JjL3V0aWxzL25vcm1hbGl6ZS1vcHRpbWl6YXRpb24nO1xuaW1wb3J0IHsgYXVnbWVudEFwcFdpdGhTZXJ2aWNlV29ya2VyIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXIvc3JjL3V0aWxzL3NlcnZpY2Utd29ya2VyJztcbmltcG9ydCB7IG5vcm1hbGl6ZSwgcmVzb2x2ZSBhcyByZXNvbHZlUGF0aCB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCBvcmEgZnJvbSAnb3JhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgUGlzY2luYSBmcm9tICdwaXNjaW5hJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsIFByZXJlbmRlckJ1aWxkZXJPdXRwdXQgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBnZXRJbmRleE91dHB1dEZpbGUsIGdldFJvdXRlcyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgUmVuZGVyT3B0aW9ucywgUmVuZGVyUmVzdWx0IH0gZnJvbSAnLi93b3JrZXInO1xuXG5leHBvcnQgY29uc3QgcmVhZEZpbGUgPSBwcm9taXNpZnkoZnMucmVhZEZpbGUpO1xuXG50eXBlIEJ1aWxkQnVpbGRlck91dHB1dCA9IEJ1aWxkZXJPdXRwdXQgJiB7XG4gIGJhc2VPdXRwdXRQYXRoOiBzdHJpbmc7XG4gIG91dHB1dFBhdGhzOiBzdHJpbmdbXTtcbiAgb3V0cHV0UGF0aDogc3RyaW5nO1xufTtcblxudHlwZSBTY2hlZHVsZUJ1aWxkc091dHB1dCA9IEJ1aWxkZXJPdXRwdXQgJiB7XG4gIHNlcnZlclJlc3VsdD86IEJ1aWxkQnVpbGRlck91dHB1dDtcbiAgYnJvd3NlclJlc3VsdD86IEJ1aWxkQnVpbGRlck91dHB1dDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSBzZXJ2ZXIgYW5kIGJyb3dzZXIgYnVpbGRzIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMgaWYgYm90aCBidWlsZHMgYXJlIHN1Y2Nlc3NmdWwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9zY2hlZHVsZUJ1aWxkcyhcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0LFxuKTogUHJvbWlzZTxTY2hlZHVsZUJ1aWxkc091dHB1dD4ge1xuICBjb25zdCBicm93c2VyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLmJyb3dzZXJUYXJnZXQpO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuc2VydmVyVGFyZ2V0KTtcblxuICBjb25zdCBicm93c2VyVGFyZ2V0UnVuID0gYXdhaXQgY29udGV4dC5zY2hlZHVsZVRhcmdldChicm93c2VyVGFyZ2V0LCB7XG4gICAgd2F0Y2g6IGZhbHNlLFxuICAgIHNlcnZpY2VXb3JrZXI6IGZhbHNlLFxuICAgIC8vIHRvZG86IGhhbmRsZSBzZXJ2aWNlIHdvcmtlciBhdWdtZW50YXRpb25cbiAgfSk7XG4gIGNvbnN0IHNlcnZlclRhcmdldFJ1biA9IGF3YWl0IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoc2VydmVyVGFyZ2V0LCB7XG4gICAgd2F0Y2g6IGZhbHNlLFxuICB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IFticm93c2VyUmVzdWx0LCBzZXJ2ZXJSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgYnJvd3NlclRhcmdldFJ1bi5yZXN1bHQgYXMgdW5rbm93biBhcyBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gICAgICBzZXJ2ZXJUYXJnZXRSdW4ucmVzdWx0IGFzIHVua25vd24gYXMgQnVpbGRCdWlsZGVyT3V0cHV0LFxuICAgIF0pO1xuXG4gICAgY29uc3Qgc3VjY2VzcyA9XG4gICAgICBicm93c2VyUmVzdWx0LnN1Y2Nlc3MgJiYgc2VydmVyUmVzdWx0LnN1Y2Nlc3MgJiYgYnJvd3NlclJlc3VsdC5iYXNlT3V0cHV0UGF0aCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVycm9yID0gYnJvd3NlclJlc3VsdC5lcnJvciB8fCAoc2VydmVyUmVzdWx0LmVycm9yIGFzIHN0cmluZyk7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzLCBlcnJvciwgYnJvd3NlclJlc3VsdCwgc2VydmVyUmVzdWx0IH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFticm93c2VyVGFyZ2V0UnVuLnN0b3AoKSwgc2VydmVyVGFyZ2V0UnVuLnN0b3AoKV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGFuZCB3cml0ZXMgdGhlbSB0b1xuICogPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluIHRoZSBicm93c2VyIHJlc3VsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmRlclVuaXZlcnNhbChcbiAgcm91dGVzOiBzdHJpbmdbXSxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4gIGJyb3dzZXJSZXN1bHQ6IEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgc2VydmVyUmVzdWx0OiBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gIGJyb3dzZXJPcHRpb25zOiBCcm93c2VyQnVpbGRlck9wdGlvbnMsXG4gIG51bVByb2Nlc3Nlcz86IG51bWJlcixcbik6IFByb21pc2U8UHJlcmVuZGVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBwcm9qZWN0TmFtZSA9IGNvbnRleHQudGFyZ2V0ICYmIGNvbnRleHQudGFyZ2V0LnByb2plY3Q7XG4gIGlmICghcHJvamVjdE5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBidWlsZGVyIHJlcXVpcmVzIGEgdGFyZ2V0LicpO1xuICB9XG5cbiAgY29uc3Qgcm9vdCA9IG5vcm1hbGl6ZShjb250ZXh0LndvcmtzcGFjZVJvb3QpO1xuICBjb25zdCBwcm9qZWN0TWV0YWRhdGEgPSBhd2FpdCBjb250ZXh0LmdldFByb2plY3RNZXRhZGF0YShwcm9qZWN0TmFtZSk7XG4gIGNvbnN0IHByb2plY3RSb290ID0gcmVzb2x2ZVBhdGgocm9vdCwgbm9ybWFsaXplKChwcm9qZWN0TWV0YWRhdGEucm9vdCBhcyBzdHJpbmcpIHx8ICcnKSk7XG5cbiAgLy8gVXNlcnMgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYmFzZSBodG1sIGZpbGUgZS5nLiBcInNyYy9ob21lLmh0bWxcIlxuICBjb25zdCBpbmRleEZpbGUgPSBnZXRJbmRleE91dHB1dEZpbGUoYnJvd3Nlck9wdGlvbnMpO1xuICBjb25zdCB7IHN0eWxlczogbm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbiB9ID0gbm9ybWFsaXplT3B0aW1pemF0aW9uKFxuICAgIGJyb3dzZXJPcHRpb25zLm9wdGltaXphdGlvbixcbiAgKTtcblxuICBjb25zdCB7IGJhc2VPdXRwdXRQYXRoID0gJycgfSA9IHNlcnZlclJlc3VsdDtcbiAgY29uc3Qgd29ya2VyID0gbmV3IFBpc2NpbmEoe1xuICAgIGZpbGVuYW1lOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnd29ya2VyLmpzJyksXG4gICAgbmFtZTogJ3JlbmRlcicsXG4gICAgbWF4VGhyZWFkczogbnVtUHJvY2Vzc2VzLFxuICB9KTtcblxuICB0cnkge1xuICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIHRoZSByb3V0ZXMgZm9yIGVhY2ggbG9jYWxlIGZyb20gdGhlIGJyb3dzZXIgb3V0cHV0LlxuICAgIGZvciAoY29uc3Qgb3V0cHV0UGF0aCBvZiBicm93c2VyUmVzdWx0Lm91dHB1dFBhdGhzKSB7XG4gICAgICBjb25zdCBsb2NhbGVEaXJlY3RvcnkgPSBwYXRoLnJlbGF0aXZlKGJyb3dzZXJSZXN1bHQuYmFzZU91dHB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgY29uc3Qgc2VydmVyQnVuZGxlUGF0aCA9IHBhdGguam9pbihiYXNlT3V0cHV0UGF0aCwgbG9jYWxlRGlyZWN0b3J5LCAnbWFpbi5qcycpO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNlcnZlckJ1bmRsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIG1haW4gYnVuZGxlOiAke3NlcnZlckJ1bmRsZVBhdGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNwaW5uZXIgPSBvcmEoYFByZXJlbmRlcmluZyAke3JvdXRlcy5sZW5ndGh9IHJvdXRlKHMpIHRvICR7b3V0cHV0UGF0aH0uLi5gKS5zdGFydCgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHJvdXRlcy5tYXAoKHJvdXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICBpbmRleEZpbGUsXG4gICAgICAgICAgICAgIGRlcGxveVVybDogYnJvd3Nlck9wdGlvbnMuZGVwbG95VXJsIHx8ICcnLFxuICAgICAgICAgICAgICBpbmxpbmVDcml0aWNhbENzczogISFub3JtYWxpemVkU3R5bGVzT3B0aW1pemF0aW9uLmlubGluZUNyaXRpY2FsLFxuICAgICAgICAgICAgICBtaW5pZnlDc3M6ICEhbm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbi5taW5pZnksXG4gICAgICAgICAgICAgIG91dHB1dFBhdGgsXG4gICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICBzZXJ2ZXJCdW5kbGVQYXRoLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5ydW4ob3B0aW9ucywgeyBuYW1lOiAncmVuZGVyJyB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSkgYXMgUmVuZGVyUmVzdWx0W107XG4gICAgICAgIGxldCBudW1FcnJvcnMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgZXJyb3JzLCB3YXJuaW5ncyB9IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICBzcGlubmVyLnN0b3AoKTtcbiAgICAgICAgICBlcnJvcnM/LmZvckVhY2goKGUpID0+IGNvbnRleHQubG9nZ2VyLmVycm9yKGUpKTtcbiAgICAgICAgICB3YXJuaW5ncz8uZm9yRWFjaCgoZSkgPT4gY29udGV4dC5sb2dnZXIud2FybihlKSk7XG4gICAgICAgICAgc3Bpbm5lci5zdGFydCgpO1xuICAgICAgICAgIG51bUVycm9ycyArPSBlcnJvcnM/Lmxlbmd0aCA/PyAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1FcnJvcnMgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFJlbmRlcmluZyBmYWlsZWQgd2l0aCAke251bUVycm9yc30gd29ya2VyIGVycm9ycy5gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc3Bpbm5lci5mYWlsKGBQcmVyZW5kZXJpbmcgcm91dGVzIHRvICR7b3V0cHV0UGF0aH0gZmFpbGVkLmApO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgfVxuICAgICAgc3Bpbm5lci5zdWNjZWVkKGBQcmVyZW5kZXJpbmcgcm91dGVzIHRvICR7b3V0cHV0UGF0aH0gY29tcGxldGUuYCk7XG5cbiAgICAgIGlmIChicm93c2VyT3B0aW9ucy5zZXJ2aWNlV29ya2VyKSB7XG4gICAgICAgIHNwaW5uZXIuc3RhcnQoJ0dlbmVyYXRpbmcgc2VydmljZSB3b3JrZXIuLi4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBhdWdtZW50QXBwV2l0aFNlcnZpY2VXb3JrZXIoXG4gICAgICAgICAgICBwcm9qZWN0Um9vdCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZShvdXRwdXRQYXRoKSxcbiAgICAgICAgICAgIGJyb3dzZXJPcHRpb25zLmJhc2VIcmVmIHx8ICcvJyxcbiAgICAgICAgICAgIGJyb3dzZXJPcHRpb25zLm5nc3dDb25maWdQYXRoLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc3Bpbm5lci5mYWlsKCdTZXJ2aWNlIHdvcmtlciBnZW5lcmF0aW9uIGZhaWxlZC4nKTtcblxuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIHNwaW5uZXIuc3VjY2VlZCgnU2VydmljZSB3b3JrZXIgZ2VuZXJhdGlvbiBjb21wbGV0ZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdm9pZCB3b3JrZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJSZXN1bHQ7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIsIHRoZW4gcmVuZGVycyBlYWNoIHJvdXRlIGluIG9wdGlvbnMucm91dGVzXG4gKiBhbmQgd3JpdGVzIHRoZW0gdG8gcHJlcmVuZGVyLzxyb3V0ZT4vaW5kZXguaHRtbCBmb3IgZWFjaCBvdXRwdXQgcGF0aCBpblxuICogdGhlIGJyb3dzZXIgcmVzdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZShcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0LFxuKTogUHJvbWlzZTxQcmVyZW5kZXJCdWlsZGVyT3V0cHV0PiB7XG4gIGNvbnN0IGJyb3dzZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuYnJvd3NlclRhcmdldCk7XG4gIGNvbnN0IGJyb3dzZXJPcHRpb25zID0gKGF3YWl0IGNvbnRleHQuZ2V0VGFyZ2V0T3B0aW9ucyhcbiAgICBicm93c2VyVGFyZ2V0LFxuICApKSBhcyB1bmtub3duIGFzIEJyb3dzZXJCdWlsZGVyT3B0aW9ucztcbiAgY29uc3QgdHNDb25maWdQYXRoID1cbiAgICB0eXBlb2YgYnJvd3Nlck9wdGlvbnMudHNDb25maWcgPT09ICdzdHJpbmcnID8gYnJvd3Nlck9wdGlvbnMudHNDb25maWcgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgcm91dGVzID0gYXdhaXQgZ2V0Um91dGVzKG9wdGlvbnMsIHRzQ29uZmlnUGF0aCwgY29udGV4dCk7XG4gIGlmICghcm91dGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IHJvdXRlcyB0byBwcmVyZW5kZXIuYCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfc2NoZWR1bGVCdWlsZHMob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHsgc3VjY2VzcywgZXJyb3IsIGJyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdCB9ID0gcmVzdWx0O1xuICBpZiAoIXN1Y2Nlc3MgfHwgIWJyb3dzZXJSZXN1bHQgfHwgIXNlcnZlclJlc3VsdCkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGVycm9yIH0gYXMgQnVpbGRlck91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyVW5pdmVyc2FsKFxuICAgIHJvdXRlcyxcbiAgICBjb250ZXh0LFxuICAgIGJyb3dzZXJSZXN1bHQsXG4gICAgc2VydmVyUmVzdWx0LFxuICAgIGJyb3dzZXJPcHRpb25zLFxuICAgIG9wdGlvbnMubnVtUHJvY2Vzc2VzLFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyKGV4ZWN1dGUpO1xuIl19